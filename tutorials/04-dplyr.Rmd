---
title: "04-dplyr"
author: "Maria Valdez C."
date: "2024-07-15"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# STAMPS 2023
## Lesson 3 - dplyr and Tidyverse

Tidyverse is a suite of powerful and cohesive R packages. The  dplyr package has commands for common data manipulation. In this lesson, we will overview the basics of using dplyr.

<img src="figures/TidyverseLogos.png" alt="Packages in Tidyverse" width="500">

Do you know how to order a data set by the entries of a row with `arrange()` or how to introduce new variables into the data set with `mutate()`?

## Installation 

You can load the whole tidyverse suite like this,

```{r}
if (!requireNamespace("tidyverse", quietly = TRUE)) {
     install.packages("tidyverse")
}
library(tidyverse)
```

but optionally, you can individually install and load dplyr (or any other in the suite such as ggplot)

```{r}
if (!requireNamespace("dplyr", quietly = TRUE)) {
     install.packages("dplyr")
}
library(dplyr)
```

Installing individual packages may increase loading speed and I personally prefer it, but any option is valid! 

## Dplyr commands

The dplyr commands designed for data manipulation operations are: 

`select()` picks variables (think columns) based on their names.
`filter()` picks cases based on their values (think filtering rows).
`arrange()` changes the ordering of the rows.
`relocate()` changes the order of columns.
`mutate()` adds new variables that are functions of existing variables
`summarise()` reduces multiple values down to a single summary.

There is another command `group_by()`,  which allows you to perform any of the above operation “by group”. 

## Preparing for some excercises 

We are going to load the data set “phylum_data.txt”, which combines microbiome counts and covariates from some water samples around Woods hole. 

Recall that we load our tables using `read.csv`: 

```{r}
DataPhylum <- read.csv("data/phylum_data.txt", sep = "\t", row.names = 1, header = T)
```

Note: `read_tsv()` is another command available for data reading in tidyverse.

## Select and Filter commands

How many variables (columns) you see in your Data? Which of these are actually of use in your analysis? How many samples (rows) were taken in January? 

`select()` and `filter()` are the commands that allow you to manipulate your data to answer this questions. `select()` allows you to keep only those columns that you are interested in exploring, from all

```{r}
names(DataPhylum)
```

Meanwhile, `filter()` allows you to select the rows of interest by some criterion. 

*Example of select:*
```{r}
select(DataPhylum, Location, Month, Acidobacteria, Chlamydiae)
```

You can use select with `contains()` or `starts_with()` if appropriate, 

```{r}
select(DataPhylum, Location, Month, contains("bacteria"))
```

(careful not to exclude variables without intention). 

*Example of filter:*

```{r}
filter(DataPhylum, Month == "Jan")
Jan_DataPhylum <- filter(DataPhylum, Month == "Jan")
```

Criteria can be combined into one:

```{r}
filter(DataPhylum, Month == "Jan" | Month == "Feb")
```

## Exercise

Build a new table (saving the changes), containing "Location", "Season", and all taxa whose name starts with "Ch", while preserving only the rows where type is "Outfall".

Tip: Since "Type" is not in the columns to be kept, you must perform filter before select.

## Piping!

Some of you may already know this, but for those of you who don't... how tedious was the previous exercise? Did you save one table for select and then another for filter?

Piping lets you state the first argument (the name of the table) before the command, and "pipe in" the data like this:

```{r}
DataPhylum %>% 
  select(Location, Month, Acidobacteria, Chlamydiae)
```

so you can do multiple commands and save all of them:

```{r}
 Jan_DataPhylum <- DataPhylum %>% 
  select(Location, Month, Acidobacteria, Chlamydiae) %>%
  filter(Month == "Jan")
```

Repeat previous exercise with piping! 

(Does the order of operations still matter? Explore!)

## rename and relocate

The last column in our data set is called "phylum_NA", showing it is probably counts for taxa that we do not recognize. We could change the name to a more descriptive name such as "unknown". We do this in dplyr by using `rename()`

```{r}
  DataPhylum %>% 
    rename(unknown = phylum_NA)
```

Relocating columns is also possible. For example, if we are interested in directly comparing the counts of unknown organisms against the covariates in our exploration, rather than having to go at the very end of the table, we may apply

```{r}
  DataPhylum %>% 
    rename(unknown = phylum_NA) %>%
    relocate(unknown, .after = Type)
```

In relocate, ".before" indicates "the columns should come before ...", and ".after" indicates "the columns should come after ...".

## mutate & arrange

`mutate()` is used to create new columns. As an example, imagine we want the log counts of Actinobacteria. We can create a modified data grame with a new column names "log_Actinobateria":

```{r}
DataPhylum %>%
  mutate(log_Actinobacteria = log(Actinobacteria)) %>% 
  relocate(log_Actinobacteria, .after = Actinobacteria)
```
`arrange()` is used to order the entries of the dataset depending on a criterion. Considering Actinobacteria again, you may want to have it ordered by counts. You can do this from small to large, or employ the extra comand "desc" to do it from large to small: 

```{r}
DataPhylum %>%
  arrange(Actinobacteria)
```


```{r}
DataPhylum %>%
  arrange(desc(Actinobacteria))
```

## Exercise

With all you have learned, create a new data frame in which you maintain only the covariates and the Acidobacteria column. For this taxon, you preserve only the positive counts (discard zero values), and obtain the log counts. Order in decreasing order on these counts. Anything you note with the seasons?

## My code for the exercise

```{r}
Acidobacteria_data <- DataPhylum %>%
  select(Location, Month, Season, Type, Acidobacteria) %>%
  filter(Acidobacteria > 0) %>%
  mutate(log_Acidobacteria = log(Acidobacteria)) %>%
  arrange(desc(Acidobacteria))

head(Acidobacteria_data)
```

## group by and summarize
`group_by()` allows you to define groups within the data set based on specific variables. Grouping the data is often a precursor to performing summary operations on the grouped data, like summarize. 

The `summarize()` function is used to calculate summary statistics or perform other operations on grouped data. It allows you to specify various summarization functions (e.g., `mean()`, `sum()`, `max()` or custom functions) to apply to a specific variable for each group. The result is a new summarized data set where each row represents a group and each column contains the summarized values.



The function `group_by()` define a category. Then we're using summarize to calculate the sum, _by group_. 

Returning to our example, say instead we want to total counts of Acidobacteria in Winter vs in Summer. We can obtain this by
```{r}
DataPhylum %>%
  group_by(Season) %>% 
  summarize(Acidobacteria = sum(Acidobacteria))
```

